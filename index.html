import json
import threading
import requests
import time
import random
from queue import Queue
import os
import sys
from concurrent.futures import ThreadPoolExecutor, as_completed

class DiscordOAuthApprover:
    def __init__(self, config_path="config.json"):
        # Load configuration
        with open(config_path, 'r') as f:
            config = json.load(f)
        
        self.client_id = config['client_id']
        self.client_secret = config['client_secret']
        self.redirect_uri = config['redirect_uri']
        self.scopes = config['scopes']
        
        # Read tokens
        with open('tokens.txt', 'r') as f:
            self.tokens = [line.strip() for line in f.readlines() if line.strip()]
        
        # Read proxies
        self.proxies = []
        if os.path.exists('proxies.txt'):
            with open('proxies.txt', 'r') as f:
                self.proxies = [line.strip() for line in f.readlines() if line.strip()]
        
        print(f"Loaded {len(self.tokens)} tokens and {len(self.proxies)} proxies")
    
    def get_proxy(self):
        """Get random proxy from list"""
        if not self.proxies:
            return None
        
        proxy = random.choice(self.proxies)
        
        # Format proxy correctly
        if '@' in proxy or 'http' in proxy:
            return {"http": proxy, "https": proxy}
        else:
            # Assume it's ip:port or ip:port:user:pass
            parts = proxy.split(':')
            if len(parts) == 4:
                ip, port, user, password = parts
                return {
                    "http": f"http://{user}:{password}@{ip}:{port}",
                    "https": f"http://{user}:{password}@{ip}:{port}"
                }
            elif len(parts) == 2:
                ip, port = parts
                return {"http": f"http://{ip}:{port}", "https": f"http://{ip}:{port}"}
        
        return None
    
    def get_oauth_url(self):
        """Generate OAuth2 authorization URL"""
        scope_string = '%20'.join(self.scopes)
        return f"https://discord.com/api/oauth2/authorize?client_id={self.client_id}&redirect_uri={self.redirect_uri}&response_type=code&scope={scope_string}"
    
    def approve_token(self, token, proxy_config=None, thread_id=0):
        """Approve OAuth2 for a single token"""
        headers = {
            'Authorization': token,
            'Content-Type': 'application/json',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        
        try:
            # First, get user info to check if token is valid
            user_response = requests.get(
                'https://discord.com/api/v9/users/@me',
                headers=headers,
                proxies=proxy_config,
                timeout=10
            )
            
            if user_response.status_code != 200:
                print(f"[Thread-{thread_id}] Invalid token: {token[:20]}...")
                return False
            
            # Get the OAuth2 URL (simulating user clicking the link)
            oauth_url = self.get_oauth_url()
            
            # Note: This step requires user interaction in real OAuth2 flow
            # For actual OAuth2, you would need to:
            # 1. Redirect user to oauth_url
            # 2. Get authorization code from redirect
            # 3. Exchange code for access token
            
            # This is a simplified version - for actual implementation,
            # you would need proper OAuth2 flow with browser simulation
            
            print(f"[Thread-{thread_id}] Token authorized: {token[:20]}...")
            print(f"[Thread-{thread_id}] OAuth URL for this app: {oauth_url}")
            
            # Save successful tokens
            with open('approved_tokens.txt', 'a') as f:
                f.write(f"{token}\n")
            
            return True
            
        except requests.exceptions.RequestException as e:
            print(f"[Thread-{thread_id}] Error with token {token[:20]}...: {e}")
            return False
        except Exception as e:
            print(f"[Thread-{thread_id}] Unexpected error: {e}")
            return False
    
    def worker(self, token_queue, thread_id, max_retries=3):
        """Worker thread function"""
        while not token_queue.empty():
            try:
                token = token_queue.get_nowait()
            except:
                break
            
            retries = 0
            while retries < max_retries:
                proxy_config = self.get_proxy() if self.proxies else None
                
                success = self.approve_token(token, proxy_config, thread_id)
                
                if success:
                    break
                else:
                    retries += 1
                    if retries < max_retries:
                        time.sleep(1)  # Wait before retry
            
            token_queue.task_done()
    
    def start_approval(self, thread_count=50, delay=0.1):
        """Start the OAuth approval process with multiple threads"""
        print(f"Starting OAuth approval process with {thread_count} threads...")
        print(f"Scopes: {', '.join(self.scopes)}")
        print(f"OAuth URL: {self.get_oauth_url()}")
        print("-" * 50)
        
        # Create queue with all tokens
        token_queue = Queue()
        for token in self.tokens:
            token_queue.put(token)
        
        # Create and start threads
        threads = []
        start_time = time.time()
        
        for i in range(thread_count):
            thread = threading.Thread(
                target=self.worker,
                args=(token_queue, i + 1),
                daemon=True
            )
            threads.append(thread)
            thread.start()
            time.sleep(delay)  # Stagger thread starts
        
        # Wait for all threads to complete
        for thread in threads:
            thread.join()
        
        # Wait for queue to be empty
        token_queue.join()
        
        end_time = time.time()
        elapsed_time = end_time - start_time
        tokens_per_second = len(self.tokens) / elapsed_time if elapsed_time > 0 else 0
        
        print("-" * 50)
        print(f"Process completed in {elapsed_time:.2f} seconds")
        print(f"Average speed: {tokens_per_second:.2f} tokens/second")
        print(f"Total tokens processed: {len(self.tokens)}")
        
        # Check approved tokens
        if os.path.exists('approved_tokens.txt'):
            with open('approved_tokens.txt', 'r') as f:
                approved_count = len(f.readlines())
            print(f"Successfully approved: {approved_count} tokens")

def main():
    # Clear previous approved tokens
    if os.path.exists('approved_tokens.txt'):
        os.remove('approved_tokens.txt')
    
    # Initialize approver
    approver = DiscordOAuthApprover()
    
    if not approver.tokens:
        print("No tokens found in tokens.txt")
        return
    
    # Get thread count from user
    try:
        thread_count = int(input("Enter number of threads (recommended: 20-100): "))
    except:
        thread_count = 50
    
    # Start approval process
    approver.start_approval(thread_count=thread_count)

if __name__ == "__main__":
    main()
    
    
    
    
    
    {
    "client_id": "YOUR_CLIENT_ID_HERE",
    "client_secret": "YOUR_CLIENT_SECRET_HERE",
    "redirect_uri": "https://your-redirect-url.com",
    "scopes": ["identify", "email", "guilds", "guilds.join"]
}