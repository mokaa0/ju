اصنع لي كود اداه بايثون اشغلها تتطبع  : def display_banner():
    mars_raw = [
        "███╗   ███╗ █████╗ ██████╗ ███████╗",
        "████╗ ████║██╔══██╗██╔══██╗██╔════╝",
        "██╔████╔██║███████║██████╔╝███████╗",
        "██║╚██╔╝██║██╔══██║██╔══██╗╚════██║",
        "██║ ╚═╝ ██║██║  ██║██║  ██║███████║",
        "╚═╝     ╚═╝╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝",
    ]

    creator = "Creator @Sha3rawy"
    token_text = "• TOKEN GENERATOR V3.0 ELITE VERSION •"

    mars_gradient = gradient_block(mars_raw, (60, 160, 255), (230, 245, 255))
    term_width = shutil.get_terminal_size().columns

    print("\n")
    for line in mars_gradient:
        pad = (term_width - len(strip_ansi(line))) // 2
        print(" " * pad + line)

    token_colored = gradient_text(token_text, (80, 190, 255), (255, 255, 255))
    token_pad = (term_width - len(token_text)) // 2
    print(" " * token_pad + token_colored)
    print()

    creator_gradient = gradient_text(creator, (80, 190, 255), (255, 255, 255))
    creator_pad = (term_width - len(creator)) // 2
    print(" " * creator_pad + creator_gradient)
    print()

def al():
    display_banner()


لكن بدل كلمة MARS خلي PLUS
وبدل لون ازرق خلي احمر داكن و ابيض نفس تدريج خلي





بنسبة للتعريفات الي بتكون جنب اي طباعه type_map = {
        "SUCCESS": f"{Fore.GREEN}[SUCCESS]{Style.RESET_ALL}",
        "ERROR": f"{Fore.RED}[ERROR]{Style.RESET_ALL}",
        "INFO": f"{Fore.LIGHTCYAN_EX}[INFO]{Style.RESET_ALL}",
        "WARNING": f"{Fore.YELLOW}[WARNING]{Style.RESET_ALL}",
        "INPUT": f"{Fore.MAGENTA}[INPUT]{Style.RESET_ALL}",
        "SYSTEM": f"{Fore.LIGHTCYAN_EX}[SYSTEM]{Style.RESET_ALL}",
        "EMAIL": f"{Fore.LIGHTGREEN_EX}[BROWSER]{Style.RESET_ALL}",
    }
و

‏        formatted_message = f"{Fore.LIGHTGREEN_EX}{message}{Style.RESET_ALL}"
‏    elif type.upper() == "INFO":
‏        formatted_message = f"{Fore.WHITE}{message}{Style.RESET_ALL}"
‏    elif type.upper() == "SYSTEM" or type.upper() == "BROWSER":
‏        formatted_message = f"{Fore.WHITE}{message}{Style.RESET_ALL}"
‏    elif type.upper() == "SUCCESS":
‏        formatted_message = f"{Fore.LIGHTGREEN_EX}{message}{Style.RESET_ALL}"
‏    elif type.upper() == "ERROR":
‏        formatted_message = f"{Fore.LIGHTRED_EX}{message}{Style.RESET_ALL}"
‏    elif type.upper() == "WARNING":
‏        formatted_message = f"{Fore.LIGHTYELLOW_EX}{message}{Style.RESET_ALL}"
‏    elif type.upper() == "INPUT":
‏        formatted_message = message
‏    elif ":" in message:
‏        parts = message.split(":", 1)
‏        key = parts[0].upper().strip()
‏        val = parts[1].strip()
‏        formatted_message = f"{key}: {Fore.WHITE}{val}{Style.RESET_ALL}"
‏    else:
‏        formatted_message = f"{Fore.WHITE}{message}{Style.RESET_ALL}"
    
‏    print(f"{Fore.WHITE}{now}]{Style.RESET_ALL} {tag} {formatted_message}")


بعدها بيطبع
بل
INFO Press Enter Start Process 
يضغط انتر بيفتح كروم بلمسار التالي chrome_paths = [
            r"C:\Program Files\Google\Chrome\Application\chrome.exe",
            r"C:\Program Files (x86)\Google\Chrome\Application\chrome.exe",
            r"C:\Users\{}\AppData\Local\Google\Chrome\Application\chrome.exe".format(os.getenv("USERNAME")),
        ]

والحمايه التاليه : browser_args = [
                "--disable-blink-features=AutomationControlled",
                "--disable-dev-shm-usage",
                "--no-sandbox",
                "--disable-setuid-sandbox",
                "--disable-web-security",
                "--disable-features=IsolateOrigins,site-per-process"
            ]


بيكتب ببحث قوقل

https://discord.gg/ZPHZHkRj48
بيظهر  input باسم Display Name ابحث عنه باكثر من طريقه يكتب فيه احرف وارقام عشوائية من ٨ خانات 
و تحتها سلكتات
Date Of Birth 

بيكون فيه ٣ سلكتات
Day , month , Year
استخدم السكريبت الثاني للاختيار   async def select_birthdate(self, page):
        try:
            months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
            random_year = random.randint(1995, 2000)
            random_day = random.randint(1, 28)
            
            month_attempts = 0
            while month_attempts < 3:
                month_attempts += 1
                random_month = random.choice(months)
                
                try:
                    month_dropdown = await page.wait_for("div[role=button][aria-label=Month]", timeout=15000)
                    await month_dropdown.click()
                    await asyncio.sleep(0.1)
                    
                    month_option = None
                    try:
                        options = await page.query_selector_all("div[role=option]")
                        if options:
                            month_map = {"january": 0, "february": 1, "march": 2, "april": 3, "may": 4, "june": 5, "july": 6, "august": 7, "september": 8, "october": 9, "november": 10, "december": 11}
                            month_index = month_map.get(random_month.lower(), 0)
                            if 0 <= month_index < len(options):
                                month_option = options[month_index]
                        
                        if not month_option:
                            for option in options:
                                try:
                                    text_content = await option.text_content()
                                    if text_content and random_month.lower() in text_content.strip().lower():
                                        month_option = option
                                        break
                                except:
                                    continue
                    except Exception as e:
                        log("ERROR", f"Error finding month options: {e}")
                    
                    if month_option:
                        await month_option.click()
                        break
                    else:
                        log("WARNING", f"Retrying month")
                        await asyncio.sleep(0.2)
                        continue
                        
                except Exception as e:
                    log("WARNING", f"Month dropdown retry due to error: {e}")
                    await asyncio.sleep(0.2)
            
            day_attempts = 0
            while day_attempts < 3:
                day_attempts += 1
                
                try:
                    day_dropdown = await page.wait_for("div[role=button][aria-label=Day]", timeout=15000)
                    await day_dropdown.click()
                    await asyncio.sleep(0.1)
                    
                    day_option = None
                    try:
                        options = await page.query_selector_all("div[role=option]")
                        if options:
                            day_index = min(random_day - 1, len(options) - 1)
                            if 0 <= day_index < len(options):
                                day_option = options[day_index]
                        
                        if not day_option:
                            for option in options:
                                try:
                                    text_content = await option.text_content()
                                    if text_content and str(random_day) in text_content.strip():
                                        day_option = option
                                        break
                                except:
                                    continue
                    except Exception as e:
                        log("ERROR", f"Error finding day options: {e}")
                    
                    if day_option:
                        await day_option.click()
                        break
                    else:
                        random_day = random.randint(1, 28)
                        log("WARNING", f"Retrying day")
                        await asyncio.sleep(0.2)
                        continue
                        
                except Exception as e:
                    log("WARNING", f"Day dropdown retry due to error: {e}")
                    await asyncio.sleep(0.2)
            
            year_attempts = 0
            while year_attempts < 3:
                year_attempts += 1
                
                try:
                    year_dropdown = await page.wait_for("div[role=button][aria-label=Year]", timeout=15000)
                    await year_dropdown.click()
                    await asyncio.sleep(0.1)
                    
                    year_option = None
                    try:
                        options = await page.query_selector_all("div[role=option]")
                        if options:
                            current_year = 2024
                            year_index = current_year - random_year
                            if 0 <= year_index < len(options):
                                year_option = options[year_index]
                        
                        if not year_option:
                            for option in options:
                                try:
                                    text_content = await option.text_content()
                                    if text_content and str(random_year) in text_content.strip():
                                        year_option = option
                                        break
                                except:
                                    continue
                    except Exception as e:
                        log("ERROR", f"Error finding year options: {e}")
                    
                    if year_option:
                        await year_option.click()
                        log("SUCCESS", "Selected Dob")
                        break
                    else:
                        random_year = random.randint(1995, 2002)
                        log("WARNING", f"Retrying year")
                        await asyncio.sleep(0.2)
                        continue
                        
                except Exception as e:
                    log("WARNING", f"Year dropdown retry due to error: {e}")
                    await asyncio.sleep(0.2)
استخدمه بلظبط لا تغير فيه شيء
بعدها بيضغط زر Create Account الازرق اول ميخلص كل الداتا يملاها يضغطه و في كابتشا بتظهر خليه يشوفها لما تظهر عن طريق السكربت ذا: captcha_elements = [
    "iframe[src*='hcaptcha']",
    "iframe[src*='recaptcha']", 
    "iframe[title*='captcha']",
    "iframe[title*='CAPTCHA']",
    "div[class*='captcha']",
    "div[id*='captcha']",
    "div[id*='CAPTCHA']",
    ".h-captcha",
    ".g-recaptcha",
    "[data-sitekey]"  # خاصية data-sitekey التي تحتوي على مفتاح الموقع
]
والتحقق منها عن طريق  for selector in captcha_elements:
    try:
        captcha = await page.query_selector(selector)
        if captcha:
            is_visible = True
            try:
                is_visible = await captcha.is_visible()
            except:
                pass
            
            if is_visible:
                captcha_found = True
                # ... استخراج sitekey
وعند وجودها يطبع 
INFO Captcha detected

ويستعمل الكود التالي لترقب حلها

‏for attempt in range(180):  # Increased timeout for solving
    # البحث عن عناصر الكابتشا
    # إذا اختفى عنصر الكابتشا بعد أن كان موجوداً
‏    if not captcha_found and captcha_detected:
‏        log("SUCCESS", "Captcha completed!")
‏        return True
ولو طلعت محلوله يطبع
INFO Captcha Solved!


لما يتاكد اننا دخلنا لرابط الصفحه ذا

discord.com/app/invite-with-guild-onboarding/ZPHZHkRj48

ينفذ السكربت ذا function setCookie(name, value, days) {
                const expires = new Date();
                expires.setTime(expires.getTime() + (days * 24 * 60 * 60 * 1000));
                document.cookie = `${name}=${value};expires=${expires.toUTCString()};path=/`;
            }

            return new Promise((resolve, reject) => {
                try {
                    function findDiscordToken(retryInterval = 1000, maxRetries = 20) {
                        return new Promise((resolveToken, rejectToken) => {
                            let attempts = 0;
                            const intervalId = setInterval(() => {
                                attempts++;
                                console.log(`Attempt ${attempts}: searching for token...`);
                                let tokenFound = false;

                                try {
                                    if (window.webpackChunkdiscord_app) {
                                        window.webpackChunkdiscord_app.push([
                                            [Math.random()],
                                            {},
                                            e => {
                                                for (const mod in e.c) {
                                                    try {
                                                        const result = e.c[mod]?.exports?.default?.getToken?.();
                                                        if (typeof result === 'string' && !result.hasOwnProperty('locale')) {
                                                            console.log('Token found:', result);
                                                            tokenFound = true;
                                                            clearInterval(intervalId);
                                                            resolveToken(result);
                                                            return;
                                                        }
                                                    } catch { }
                                                }
                                            }
                                        ]);
                                    } else {
                                        console.log('webpackChunkdiscord_app not found yet');
                                    }
                                } catch (err) {
                                    console.error('Error during token search:', err);
                                }

                                if (attempts >= maxRetries && !tokenFound) {
                                    clearInterval(intervalId);
                                    rejectToken('Token not found after max retries.');
                                }
                            }, retryInterval);
                        });
                    }

                    // Usage:
                    findDiscordToken().then(token => {
                        setCookie('discordUserToken', token, 7);
                        resolve(token);
                    }).catch(err => {
                        console.error(err);
                        reject(err);
                    });
                } catch (error) {
                    console.log('error:', error);
                    reject(error);
                }
            });
            
وذا

‏function getCookie(name) {
‏                const value = `; ${document.cookie}`;
‏                const parts = value.split(`; ${name}=`);
‏                if (parts.length === 2) return parts.pop().split(';').shift();
‏                return null;
            }
            
‏            return getCookie('discordUserToken');

وياخذ الناتج يلصقه بسطر لوحده بملف tok