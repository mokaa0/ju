const fs = require('fs');
const { Client } = require('discord.js-selfbot-v13');
const { HttpsProxyAgent } = require('https-proxy-agent');
const { SocksProxyAgent } = require('socks-proxy-agent');

class DiscordSelfbotUsernameChanger {
    constructor() {
        this.tokens = [];
        this.usernames = [];
        this.proxies = [];
        this.successCount = 0;
        this.failCount = 0;
        this.currentProxyIndex = 0;
        this.clients = [];
    }

    colors = {
        purple: '\x1b[35m',
        red: '\x1b[31m',
        green: '\x1b[32m',
        yellow: '\x1b[33m',
        reset: '\x1b[0m'
    };

    async loadFiles() {
        try {
            const tokensContent = fs.readFileSync('tokens.txt', 'utf8');
            this.tokens = tokensContent.split('\n')
                .map(token => token.trim())
                .filter(token => token.length > 0);

            const usernamesContent = fs.readFileSync('username.txt', 'utf8');
            this.usernames = usernamesContent.split('\n')
                .map(username => username.trim())
                .filter(username => username.length > 0);

            const proxiesContent = fs.readFileSync('proxies.txt', 'utf8');
            this.proxies = proxiesContent.split('\n')
                .map(proxy => proxy.trim())
                .filter(proxy => proxy.length > 0);

            console.log(`${this.colors.green}Loaded ${this.tokens.length} tokens${this.colors.reset}`);
            console.log(`${this.colors.green}Loaded ${this.usernames.length} usernames${this.colors.reset}`);
            console.log(`${this.colors.green}Loaded ${this.proxies.length} proxies${this.colors.reset}`);

            if (this.tokens.length !== this.usernames.length) {
                console.log(`${this.colors.yellow}Warning: Number of tokens (${this.tokens.length}) does not match number of usernames (${this.usernames.length})${this.colors.reset}`);
            }

            return true;
        } catch (error) {
            console.error(`${this.colors.red}Error loading files: ${error.message}${this.colors.reset}`);
            return false;
        }
    }

    getProxyForAccount(index) {
        if (this.proxies.length === 0) return null;
        
        const proxyIndex = index % this.proxies.length;
        return this.proxies[proxyIndex];
    }

    createProxyAgent(proxy) {
        if (!proxy) return null;
        
        try {
            if (proxy.includes('socks4://') || proxy.includes('socks5://')) {
                return new SocksProxyAgent(proxy);
            }
            else if (proxy.includes('://')) {
                return new HttpsProxyAgent(proxy);
            }
            else {
                const [ip, port] = proxy.split(':');
                if (ip && port) {
                    return new HttpsProxyAgent(`http://${ip}:${port}`);
                }
            }
        } catch (error) {
            console.error(`${this.colors.red}Error creating proxy agent: ${error.message}${this.colors.reset}`);
        }
        
        return null;
    }

    getCurrentTime() {
        const now = new Date();
        return now.toLocaleTimeString('en-US', {
            hour12: true,
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
    }

    async createClient(token, proxy, index) {
        return new Promise((resolve) => {
            const proxyAgent = this.createProxyAgent(proxy);
            
            const client = new Client({
                checkUpdate: false,
                restRequestTimeout: 30000
            });

            client.on('ready', () => {
                resolve(client);
            });

            client.on('error', (error) => {
                console.error(`${this.colors.red}Client ${index + 1} error: ${error.message}${this.colors.reset}`);
            });

            const loginOptions = {
                agent: proxyAgent
            };

            client.login(token).catch(error => {
                console.error(`${this.colors.red}Failed to login client ${index + 1}: ${error.message}${this.colors.reset}`);
                resolve(null);
            });
        });
    }

    async changeUsernameWithSelfbot(client, newUsername, index) {
        try {
            const oldUsername = client.user.username;
            
            await client.user.setUsername(newUsername);
            
            const currentTime = this.getCurrentTime();
            console.log(`\n${this.colors.purple}[${currentTime}]${this.colors.reset} Processing account ${index + 1}/${this.tokens.length}`);
            console.log(`${this.colors.red}Old username: ${oldUsername}${this.colors.reset}`);
            console.log(`${this.colors.green}New username: ${newUsername}${this.colors.reset}`);
            
            this.successCount++;
            return true;
        } catch (error) {
            const currentTime = this.getCurrentTime();
            console.log(`\n${this.colors.purple}[${currentTime}]${this.colors.reset} Processing account ${index + 1}/${this.tokens.length}`);
            console.error(`${this.colors.red}Failed to change username: ${error.message}${this.colors.reset}`);
            
            this.failCount++;
            return false;
        }
    }

    async processAccount(index) {
        const token = this.tokens[index];
        const username = this.usernames[index];
        const proxy = this.getProxyForAccount(index);

        console.log(`\n${this.colors.purple}[${this.getCurrentTime()}]${this.colors.reset} Initializing account ${index + 1}/${this.tokens.length}...`);
        
        try {
            const client = await this.createClient(token, proxy, index);
            
            if (!client) {
                console.error(`${this.colors.red}Failed to create client for account ${index + 1}${this.colors.reset}`);
                this.failCount++;
                return;
            }

            console.log(`${this.colors.green}Successfully logged in as: ${client.user.tag}${this.colors.reset}`);
            
            await this.changeUsernameWithSelfbot(client, username, index);
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            client.destroy();
            
        } catch (error) {
            console.error(`${this.colors.red}Error processing account ${index + 1}: ${error.message}${this.colors.reset}`);
            this.failCount++;
        }
    }

    async processAllAccounts() {
        const totalAccounts = Math.min(this.tokens.length, this.usernames.length);
        
        for (let i = 0; i < totalAccounts; i++) {
            await this.processAccount(i);
            
            if (i < totalAccounts - 1) {
                await new Promise(resolve => setTimeout(resolve, 3000));
            }
        }
    }

    showResults() {
        console.log(`\n${this.colors.green}=== PROCESS COMPLETED ===${this.colors.reset}`);
        console.log(`${this.colors.green}Successful: ${this.successCount}${this.colors.reset}`);
        console.log(`${this.colors.red}Failed: ${this.failCount}${this.colors.reset}`);
        console.log(`${this.colors.yellow}Total tokens: ${this.tokens.length}${this.colors.reset}`);
    }

    async start() {
        console.log(`${this.colors.purple}Starting username change process using Selfbot...${this.colors.reset}\n`);

        const filesLoaded = await this.loadFiles();
        if (!filesLoaded) {
            console.log(`${this.colors.red}Failed to load files${this.colors.reset}`);
            return;
        }

        if (this.tokens.length === 0 || this.usernames.length === 0) {
            console.log(`${this.colors.red}Token or username files are empty${this.colors.reset}`);
            return;
        }

        await this.processAllAccounts();
        this.showResults();
        
        process.exit(0);
    }
}

const changer = new DiscordSelfbotUsernameChanger();
changer.start().catch(console.error);