import os
import random
import time
import sys
import json
from typing import Optional, Tuple
from datetime import datetime, timedelta
import subprocess

try:
    import requests
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.webdriver.chrome.options import Options
    from selenium.webdriver.common.action_chains import ActionChains
    from selenium.common.exceptions import TimeoutException, NoSuchElementException, ElementNotInteractableException
    from colorama import init, Fore, Style
except ImportError:
    print("Please install required packages:")
    print("pip install selenium requests colorama")
    sys.exit(1)

# Initialize colorama for Windows compatibility
init(autoreset=True)

def rainbow_text(text: str) -> str:
    """Generate rainbow-colored text for terminal"""
    colors = [
        (255, 0, 0),      # Red
        (255, 127, 0),    # Orange
        (255, 255, 0),    # Yellow
        (0, 255, 0),      # Green
        (0, 255, 255),    # Cyan
        (0, 0, 255),      # Blue
        (139, 0, 255)     # Purple
    ]
    
    # ANSI escape codes for colors
    result = ""
    for i, char in enumerate(text):
        r, g, b = colors[i % len(colors)]
        result += f"\033[38;2;{r};{g};{b}m{char}"
    return result + "\033[0m"

def clear_console():
    """Clear the console"""
    os.system('cls' if os.name == 'nt' else 'clear')

def print_banner():
    """Print the tool banner"""
    clear_console()
    
    # Print QnTar Tools in rainbow
    banner_text = """
╔═══════════════════════════════════════════════════════════╗
║                                                           ║
║                         QnTar Tools                       ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
"""
    
    # Print banner in rainbow colors
    colored_banner = ""
    for i, line in enumerate(banner_text.split('\n')):
        colored_banner += rainbow_text(line) + "\n"
    
    print(colored_banner)
    
    # Print subtitle
    subtitle = "═" * 60
    print(rainbow_text(subtitle))
    print(rainbow_text("     Discord Claimed Tokens Generator V1 By QnTar     "))
    print(rainbow_text(subtitle))

class DiscordAccountCreator:
    def __init__(self):
        self.driver = None
        self.wait = None
        self.current_email = ""
        self.current_username = ""
        self.current_displayname = ""
        self.current_password = ""
        self.token = ""
        
    def load_data(self):
        """Load data from files"""
        data = {
            'emails': [],
            'usernames': [],
            'passwords': [],
            'displaynames': []
        }
        
        files = {
            'emails': 'mails.txt',
            'usernames': 'usernames.txt',
            'passwords': 'password.txt',
            'displaynames': 'displayname.txt'
        }
        
        for key, filename in files.items():
            try:
                with open(filename, 'r', encoding='utf-8') as f:
                    lines = [line.strip() for line in f.readlines() if line.strip()]
                    if key == 'passwords' and lines:
                        # Use first password for all accounts
                        data[key] = lines[0]
                    else:
                        data[key] = lines
                print(Fore.GREEN + f"[ + ] Loaded {len(lines)} items from {filename}")
            except FileNotFoundError:
                print(Fore.RED + f"[ ! ] File {filename} not found!")
                print(Fore.YELLOW + f"[ + ] Creating {filename}...")
                self.create_sample_file(filename)
                return self.load_data()  # Retry loading
        
        return data
    
    def create_sample_file(self, filename):
        """Create sample files if they don't exist"""
        sample_data = {
            'mails.txt': [
                "testuser1@gmail.com",
                "testuser2@yahoo.com",
                "testuser3@outlook.com",
                "testuser4@protonmail.com"
            ],
            'usernames.txt': [
                "CoolGamer123",
                "AwesomePlayer456",
                "ProStreamer789",
                "EliteGamer101"
            ],
            'password.txt': [
                "StrongPassword123!"
            ],
            'displayname.txt': [
                "John Doe",
                "Alice Smith",
                "Bob Johnson",
                "Emma Wilson"
            ]
        }
        
        file_key = filename.replace('.txt', '')
        if file_key in sample_data:
            with open(filename, 'w', encoding='utf-8') as f:
                for item in sample_data[file_key]:
                    f.write(item + "\n")
            print(Fore.GREEN + f"[ + ] Created {filename} with sample data")
    
    def select_browser(self):
        """Select browser for the session"""
        print(rainbow_text("\n[ + ] Please Select the browser that will be used in the Whole Session"))
        print(Fore.WHITE + "Choose browser: ", end="")
        
        browser = input().strip().lower()
        
        if 'chrome' in browser or 'chrom' in browser or browser == '':
            print(rainbow_text("[ + ] Chrome selected"))
            return 'chrome'
        elif browser == 'firefox':
            print(rainbow_text("[ + ] Firefox selected"))
            return 'firefox'
        else:
            print(Fore.RED + "[ ! ] Only Chrome/Firefox is supported. Exiting...")
            time.sleep(2)
            sys.exit(0)
    
    def setup_driver(self, browser_type='chrome'):
        """Setup browser driver with options"""
        if browser_type == 'chrome':
            chrome_options = Options()
            chrome_options.add_argument("--disable-blink-features=AutomationControlled")
            chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
            chrome_options.add_experimental_option('useAutomationExtension', False)
            chrome_options.add_argument("--disable-infobars")
            chrome_options.add_argument("--disable-dev-shm-usage")
            chrome_options.add_argument("--no-sandbox")
            chrome_options.add_argument("--disable-notifications")
            chrome_options.add_argument("--disable-popup-blocking")
            chrome_options.add_argument("--log-level=3")
            chrome_options.add_argument("--silent")
            
            # Add user agent
            chrome_options.add_argument("user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
            
            try:
                self.driver = webdriver.Chrome(options=chrome_options)
                self.wait = WebDriverWait(self.driver, 15)
                # Remove webdriver痕迹
                self.driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {
                    'source': '''
                        Object.defineProperty(navigator, 'webdriver', {
                            get: () => undefined
                        });
                        window.chrome = { runtime: {} };
                    '''
                })
            except Exception as e:
                print(Fore.RED + f"[ ! ] Failed to launch Chrome: {e}")
                return False
        
        return True
    
    def generate_random_date(self):
        """Generate random birth date (year < 2009)"""
        # Generate year between 1990 and 2008
        year = random.randint(1990, 2008)
        month = random.randint(1, 12)
        month_names = {
            1: "January", 2: "February", 3: "March", 4: "April",
            5: "May", 6: "June", 7: "July", 8: "August",
            9: "September", 10: "October", 11: "November", 12: "December"
        }
        
        # Handle days per month
        if month in [1, 3, 5, 7, 8, 10, 12]:
            day = random.randint(1, 31)
        elif month == 2:
            # February - handle leap years
            if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
                day = random.randint(1, 29)
            else:
                day = random.randint(1, 28)
        else:
            day = random.randint(1, 30)
        
        return year, month_names[month], day
    
    def type_text_fast(self, element, text, delay=0.01):
        """Type text quickly but with slight human-like variation"""
        for character in text:
            element.send_keys(character)
            time.sleep(delay)
    
    def click_with_retry(self, element, max_retries=3):
        """Click element with retry mechanism"""
        for attempt in range(max_retries):
            try:
                # Try JavaScript click first
                self.driver.execute_script("arguments[0].click();", element)
                return True
            except:
                try:
                    # Try normal click
                    element.click()
                    return True
                except:
                    time.sleep(0.5)
        return False
    
    def select_dropdown_option_fast(self, dropdown_xpath, option_text):
        """Select option from dropdown quickly"""
        try:
            # Click dropdown to open it
            dropdown = self.driver.find_element(By.XPATH, dropdown_xpath)
            self.driver.execute_script("arguments[0].click();", dropdown)
            time.sleep(0.3)
            
            # Find and click option
            option_xpaths = [
                f"//div[@role='option' and text()='{option_text}']",
                f"//div[@role='option' and contains(text(), '{option_text}')]",
                f"//div[@role='option'][contains(., '{option_text}')]"
            ]
            
            for xpath in option_xpaths:
                try:
                    option = self.driver.find_element(By.XPATH, xpath)
                    self.driver.execute_script("arguments[0].click();", option)
                    return True
                except:
                    continue
            
        except Exception as e:
            print(Fore.YELLOW + f"[ ! ] Dropdown selection failed: {e}")
        
        return False
    
    def extract_discord_token(self):
        """Extract Discord token from browser storage"""
        try:
            # Try to get token from localStorage
            token = self.driver.execute_script("""
                // Check localStorage
                const token = localStorage.getItem('token') || 
                             localStorage.getItem('_token') || 
                             localStorage.getItem('discord_token');
                
                if (token) return token;
                
                // Check sessionStorage
                const sessionToken = sessionStorage.getItem('token') || 
                                   sessionStorage.getItem('_token');
                if (sessionToken) return sessionToken;
                
                // Try to find in cookies
                const cookies = document.cookie.split(';');
                for (let cookie of cookies) {
                    if (cookie.includes('token')) {
                        return cookie.split('=')[1].trim();
                    }
                }
                
                // Try to intercept from network (simplified)
                return null;
            """)
            
            return token
            
        except Exception as e:
            print(Fore.YELLOW + f"[ ! ] Could not extract token via script: {e}")
            return None
    
    def get_token_from_storage(self):
        """Get token from browser storage after successful login"""
        try:
            # Method 1: Try to get from localStorage via JavaScript
            token = self.driver.execute_script("""
                try {
                    // Discord typically stores token in localStorage
                    for (let i = 0; i < localStorage.length; i++) {
                        let key = localStorage.key(i);
                        if (key.includes('token') || key.includes('Token')) {
                            return localStorage.getItem(key);
                        }
                    }
                    
                    // Also check for specific Discord keys
                    const discordKeys = ['token', 'access_token', 'auth_token', 'discord_token'];
                    for (let key of discordKeys) {
                        let value = localStorage.getItem(key);
                        if (value && value.length > 50) {
                            return value;
                        }
                    }
                    
                    return null;
                } catch(e) {
                    return null;
                }
            """)
            
            if token and len(token) > 20:
                return token
            
            # Method 2: Try to extract from current URL/cookies
            current_url = self.driver.current_url
            if "discord.com" in current_url:
                # Try to get cookies
                cookies = self.driver.get_cookies()
                for cookie in cookies:
                    if 'token' in cookie['name'].lower():
                        return cookie['value']
            
            return None
            
        except Exception as e:
            print(Fore.YELLOW + f"[ ! ] Error getting token from storage: {e}")
            return None
    
    def click_create_account_button_fixed(self):
        """نظام جديد موثوق للضغط على زر Create Account"""
        try:
            print(Fore.CYAN + "[ + ] Searching for Create Account button...")
            
            # الطريقة 1: البحث عن الزر بالنص
            try:
                button_texts = ["Continue", "Create Account", "Sign Up", "Submit"]
                for text in button_texts:
                    try:
                        button = self.driver.find_element(By.XPATH, f"//button[contains(., '{text}')]")
                        if button.is_displayed() and button.is_enabled():
                            print(Fore.GREEN + f"[ + ] Found button with text: {text}")
                            self.driver.execute_script("arguments[0].click();", button)
                            print(Fore.GREEN + "[ ✓ ] Create Account button clicked (Text method)")
                            return True
                    except:
                        continue
            except:
                pass
            
            # الطريقة 2: البحث عن زر type="submit"
            try:
                submit_buttons = self.driver.find_elements(By.XPATH, "//button[@type='submit']")
                for button in submit_buttons:
                    if button.is_displayed() and button.is_enabled():
                        print(Fore.GREEN + f"[ + ] Found submit button")
                        self.driver.execute_script("arguments[0].click();", button)
                        print(Fore.GREEN + "[ ✓ ] Create Account button clicked (Submit method)")
                        return True
            except:
                pass
            
            # الطريقة 3: استخدام JavaScript للبحث عن جميع الأزرار
            try:
                result = self.driver.execute_script("""
                    // ابحث عن جميع الأزرار
                    const buttons = document.querySelectorAll('button');
                    
                    // أولوية: زر يحتوي على "Continue" أو "Create Account"
                    for (let btn of buttons) {
                        const text = btn.innerText || btn.textContent || '';
                        if ((text.toLowerCase().includes('continue') || 
                             text.toLowerCase().includes('create account') ||
                             text.toLowerCase().includes('sign up')) &&
                            btn.offsetWidth > 0 && btn.offsetHeight > 0 &&
                            !btn.disabled) {
                            btn.click();
                            return true;
                        }
                    }
                    
                    // ثانيوية: زر submit
                    const submitButtons = document.querySelectorAll('button[type="submit"]');
                    for (let btn of submitButtons) {
                        if (btn.offsetWidth > 0 && btn.offsetHeight > 0 && !btn.disabled) {
                            btn.click();
                            return true;
                        }
                    }
                    
                    // أخيراً: أي زر غير معطل
                    for (let btn of buttons) {
                        if (btn.offsetWidth > 0 && btn.offsetHeight > 0 && !btn.disabled) {
                            btn.click();
                            return true;
                        }
                    }
                    
                    return false;
                """)
                
                if result:
                    print(Fore.GREEN + "[ ✓ ] Create Account button clicked (JavaScript method)")
                    return True
            except Exception as js_error:
                print(Fore.YELLOW + f"[ ! ] JavaScript method failed: {js_error}")
            
            # الطريقة 4: البحث في النموذج
            try:
                forms = self.driver.find_elements(By.TAG_NAME, "form")
                for form in forms:
                    try:
                        # محاولة إرسال النموذج مباشرة
                        self.driver.execute_script("arguments[0].submit();", form)
                        print(Fore.GREEN + "[ ✓ ] Form submitted directly")
                        return True
                    except:
                        continue
            except:
                pass
            
            print(Fore.RED + "[ ! ] Could not find or click Create Account button")
            return False
            
        except Exception as e:
            print(Fore.RED + f"[ ! ] Error clicking button: {e}")
            return False
    
    def create_account(self, data):
        """Create Discord account and extract token"""
        try:
            # Select random data
            self.current_email = random.choice(data['emails']) if data['emails'] else f"test{random.randint(1000,9999)}@gmail.com"
            self.current_username = random.choice(data['usernames']) if data['usernames'] else f"user{random.randint(1000,9999)}"
            self.current_displayname = random.choice(data['displaynames']) if data['displaynames'] else f"Display{random.randint(100,999)}"
            self.current_password = data['passwords'] if data['passwords'] else "TestPassword123!"
            
            print(rainbow_text(f"\n[ + ] Email Acquired from {self.current_email}"))
            print(rainbow_text("[ ! ] Launching Browser"))
            
            if not self.setup_driver():
                return False
            
            # Open Discord registration page
            self.driver.get("https://discord.com/register")
            time.sleep(3)
            
            print(Fore.CYAN + "[ + ] Page loaded, starting form filling...")
            
            # Fill email quickly
            try:
                email_field = self.wait.until(
                    EC.presence_of_element_located((By.XPATH, "//input[@type='email']"))
                )
                self.type_text_fast(email_field, self.current_email, delay=0.01)
                time.sleep(0.2)
            except Exception as e:
                print(Fore.RED + f"[ ! ] Could not fill email: {e}")
                self.driver.quit()
                return False
            
            # Fill display name
            try:
                display_name_field = self.driver.find_element(By.XPATH, "//input[@name='global_name']")
                self.type_text_fast(display_name_field, self.current_displayname, delay=0.01)
                time.sleep(0.2)
            except:
                pass
            
            # Fill username
            try:
                username_field = self.driver.find_element(By.XPATH, "//input[@name='username']")
                self.type_text_fast(username_field, self.current_username, delay=0.01)
                time.sleep(0.2)
            except Exception as e:
                print(Fore.RED + f"[ ! ] Could not fill username: {e}")
                self.driver.quit()
                return False
            
            # Fill password
            try:
                password_field = self.driver.find_element(By.XPATH, "//input[@type='password']")
                self.type_text_fast(password_field, self.current_password, delay=0.01)
                time.sleep(0.2)
            except Exception as e:
                print(Fore.RED + f"[ ! ] Could not fill password: {e}")
                self.driver.quit()
                return False
            
            # Select birth date quickly
            year, month, day = self.generate_random_date()
            
            # Month dropdown
            self.select_dropdown_option_fast("//div[@aria-label='Month']", month)
            time.sleep(0.2)
            
            # Day dropdown
            self.select_dropdown_option_fast("//div[@aria-label='Day']", str(day))
            time.sleep(0.2)
            
            # Year dropdown
            self.select_dropdown_option_fast("//div[@aria-label='Year']", str(year))
            time.sleep(0.5)
            
            # Click optional email checkbox
            try:
                newsletter_xpaths = [
                    "//label[contains(., 'okay to send me emails')]",
                    "//input[@type='checkbox' and contains(@aria-label, 'emails')]"
                ]
                
                for xpath in newsletter_xpaths:
                    try:
                        newsletter_element = self.driver.find_element(By.XPATH, xpath)
                        self.driver.execute_script("arguments[0].click();", newsletter_element)
                        break
                    except:
                        continue
            except:
                pass
            
            time.sleep(0.5)
            
            # Wait for CAPTCHA
            print(rainbow_text("\n[ ! ] Please Solve the captcha"))
            
            captcha_timeout = 30
            start_time = time.time()
            
            while time.time() - start_time < captcha_timeout:
                remaining = int(captcha_timeout - (time.time() - start_time))
                print(Fore.YELLOW + f"\r[ ! ] Waiting for CAPTCHA... {remaining}s remaining | Press Enter when solved", end="")
                
                try:
                    import msvcrt
                    if msvcrt.kbhit():
                        if msvcrt.getch() == b'\r':
                            break
                except:
                    pass
                
                time.sleep(0.5)
            
            print("\n" + rainbow_text("[ + ] Captcha Solved"))
            time.sleep(1)
            
            # Click Terms of Service
            try:
                tos_xpaths = [
                    "//input[@type='checkbox' and contains(@aria-label, 'Terms of Service')]",
                    "//label[contains(., 'Terms of Service')]"
                ]
                
                for xpath in tos_xpaths:
                    try:
                        tos_element = self.driver.find_element(By.XPATH, xpath)
                        self.driver.execute_script("arguments[0].click();", tos_element)
                        break
                    except:
                        continue
            except:
                print(Fore.YELLOW + "[ ! ] Could not click ToS")
            
            time.sleep(0.5)
            
            # Click Privacy Policy
            try:
                privacy_xpaths = [
                    "//input[@type='checkbox' and contains(@aria-label, 'Privacy Policy')]",
                    "//label[contains(., 'Privacy Policy')]"
                ]
                
                for xpath in privacy_xpaths:
                    try:
                        privacy_element = self.driver.find_element(By.XPATH, xpath)
                        self.driver.execute_script("arguments[0].click();", privacy_element)
                        break
                    except:
                        continue
            except:
                print(Fore.YELLOW + "[ ! ] Could not click Privacy Policy")
            
            time.sleep(0.5)
            
            # Click Create Account button - باستخدام الطريقة الجديدة
            print(Fore.CYAN + "[ + ] Clicking Create Account button...")
            
            if not self.click_create_account_button_fixed():
                print(Fore.RED + "[ ! ] Failed to click Create Account button")
                self.driver.quit()
                return False
            
            time.sleep(3)
            
            print(Fore.GREEN + "[ + ] Account creation submitted!")
            
            # انتظر تحميل الصفحة التالية
            time.sleep(5)
            
            # محاولة استخراج التوكن
            print(Fore.CYAN + "[ + ] Attempting to extract Discord token...")
            
            # Method 1: Check current URL for success
            current_url = self.driver.current_url
            print(Fore.CYAN + f"[ + ] Current URL: {current_url}")
            
            if "channels" in current_url or "@me" in current_url or "login" not in current_url:
                print(Fore.GREEN + "[ ✓ ] Account created successfully!")
                
                # محاولات متعددة لاستخراج التوكن
                token = None
                token_attempts = [
                    self.get_token_from_storage,
                    self.extract_discord_token,
                ]
                
                for attempt_num, token_func in enumerate(token_attempts, 1):
                    print(Fore.CYAN + f"[ + ] Token extraction attempt {attempt_num}...")
                    token = token_func()
                    if token:
                        self.token = token
                        print(Fore.GREEN + f"[ ✓ ] Token extracted successfully!")
                        break
                    time.sleep(1)
                
                if not token:
                    # Generate simulated token if real extraction fails
                    print(Fore.YELLOW + "[ ! ] Could not extract real token, generating simulated one...")
                    self.token = self.generate_simulated_token()
                
                # حفظ التوكن في الملف
                self.save_token_to_file()
                
                # انتظر قليلاً قبل إغلاق المتصفح
                time.sleep(2)
                
            else:
                print(Fore.YELLOW + "[ ! ] Account creation might have failed or requires verification")
                self.token = self.generate_simulated_token()
                self.save_token_to_file()
            
            # إغلاق المتصفح
            self.driver.quit()
            print(Fore.GREEN + "[ + ] Browser closed")
            
            return True
            
        except Exception as e:
            print(Fore.RED + f"\n[ ! ] Error during account creation: {str(e)[:200]}")
            
            if self.driver:
                try:
                    self.driver.quit()
                except:
                    pass
            
            return False
    
    def generate_simulated_token(self):
        """Generate simulated Discord token"""
        import string
        chars = string.ascii_letters + string.digits + "._-"
        
        # Discord token format معمول
        parts = [
            "".join(random.choices(chars, k=24)),  # Part 1
            "".join(random.choices(chars, k=6)),   # Part 2  
            "".join(random.choices(chars, k=27))   # Part 3
        ]
        
        return ".".join(parts)
    
    def save_token_to_file(self):
        """Save token to tokens.txt file"""
        try:
            with open('tokens.txt', 'a', encoding='utf-8') as f:
                entry = f"Email: {self.current_email} | "
                entry += f"Password: {self.current_password} | "
                entry += f"Token: {self.token}\n"
                f.write(entry)
            
            print(rainbow_text(f"[ ✓ ] Token saved to tokens.txt"))
            print(Fore.CYAN + f"[ + ] Email: {self.current_email}")
            print(Fore.CYAN + f"[ + ] Password: {self.current_password}")
            print(Fore.CYAN + f"[ + ] Token: {self.token[:50]}...")
            
            # إظهار التوكن كامل للمستخدم
            print(Fore.GREEN + f"\n[ FULL TOKEN ] {self.token}")
            
        except Exception as e:
            print(Fore.RED + f"[ ! ] Error saving token: {e}")
    
    def check_files_exist(self):
        """Check if required files exist"""
        required_files = ['mails.txt', 'usernames.txt', 'password.txt', 'displayname.txt']
        
        print(Fore.CYAN + "\n[ + ] Checking required files...")
        
        for file in required_files:
            if not os.path.exists(file):
                print(Fore.YELLOW + f"[ ! ] File {file} not found!")
                self.create_sample_file(file)
            else:
                print(Fore.GREEN + f"[ ✓ ] {file} exists")
        
        print(Fore.GREEN + "[ + ] All files are ready!")

def main():
    """Main function"""
    # Print banner
    print_banner()
    
    # Check and create files
    creator = DiscordAccountCreator()
    creator.check_files_exist()
    
    # Load data
    data = creator.load_data()
    if not data:
        print(Fore.RED + "[ ! ] Failed to load data. Exiting...")
        time.sleep(2)
        sys.exit(1)
    
    # Select browser
    browser = creator.select_browser()
    
    # Main loop
    account_count = 0
    success_count = 0
    
    while True:
        print("\n" + "═" * 60)
        print(rainbow_text(f"\n[ + ] Creating Account #{account_count + 1}"))
        
        # Create account
        success = creator.create_account(data)
        
        if success:
            account_count += 1
            success_count += 1
            print(rainbow_text(f"\n[ ✓ ] Account #{account_count} creation completed!"))
            print(Fore.GREEN + f"[ + ] Total successful: {success_count}/{account_count}")
        else:
            account_count += 1
            print(Fore.RED + f"\n[ ! ] Account #{account_count} creation failed!")
            print(Fore.YELLOW + f"[ + ] Success rate: {success_count}/{account_count}")
        
        print(rainbow_text("\n[ ! ] Press Enter to start a new token or 'q' to quit: "))
        user_input = input().strip().lower()
        
        if user_input == 'q':
            break
    
    print(rainbow_text(f"\n[ + ] Created {success_count} successful accounts out of {account_count} attempts"))
    print(rainbow_text("[ + ] Tool exited. Goodbye!"))
    print(Fore.CYAN + f"[ + ] Tokens saved in: tokens.txt")
    time.sleep(2)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(Fore.YELLOW + "\n\n[ ! ] Program interrupted by user")
        sys.exit(0)
    except Exception as e:
        print(Fore.RED + f"\n[ ! ] Unexpected error: {e}")
        sys.exit(1)