import os
import random
import time
import sys
from typing import Optional, Tuple
from datetime import datetime, timedelta

try:
    import requests
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.webdriver.chrome.options import Options
    from selenium.common.exceptions import TimeoutException, NoSuchElementException
    from colorama import init, Fore, Style
except ImportError:
    print("Please install required packages:")
    print("pip install selenium requests colorama")
    sys.exit(1)

# Initialize colorama for Windows compatibility
init(autoreset=True)

def rainbow_text(text: str) -> str:
    """Generate rainbow-colored text for terminal"""
    colors = [
        (255, 0, 0),      # Red
        (255, 127, 0),    # Orange
        (255, 255, 0),    # Yellow
        (0, 255, 0),      # Green
        (0, 255, 255),    # Cyan
        (0, 0, 255),      # Blue
        (139, 0, 255)     # Purple
    ]
    
    # ANSI escape codes for colors
    result = ""
    for i, char in enumerate(text):
        r, g, b = colors[i % len(colors)]
        result += f"\033[38;2;{r};{g};{b}m{char}"
    return result + "\033[0m"

def clear_console():
    """Clear the console"""
    os.system('cls' if os.name == 'nt' else 'clear')

def print_banner():
    """Print the tool banner"""
    clear_console()
    
    # Print QnTar Tools in rainbow
    banner = """
╔═══════════════════════════════════════════════════════════╗
║                                                           ║
║    ██████   ███   █████  ████████  █████  ██████         ║
║   ██    ██ ██████ ██   ██    ██    ██   ██ ██   ██       ║
║   ██    ██ ██ ██ ███████    ██    ███████ ██████        ║
║   ██    ██ ██   ██ ██   ██    ██    ██   ██ ██   ██       ║
║    ██████  ██   ██ ██   ██    ██    ██   ██ ██   ██       ║
║                                                           ║
║                  ████████ ██████  ██████  ██      ███████ ║
║                  ██      ██    ██ ██   ██ ██      ██      ║
║                  █████   ██    ██ ██████  ██      ███████ ║
║                  ██      ██    ██ ██   ██ ██           ██ ║
║                  ██       ██████  ██   ██ ███████ ███████ ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
"""
    
    print(rainbow_text(banner))
    
    # Print subtitle
    subtitle = "\n" + "═" * 60 + "\n"
    subtitle += rainbow_text("     Discord Claimed Tokens Generator V1 By QnTar     ")
    subtitle += "\n" + "═" * 60 + "\n"
    print(subtitle)

class DiscordAccountCreator:
    def __init__(self):
        self.driver = None
        self.wait = None
        self.current_email = ""
        self.current_username = ""
        self.current_displayname = ""
        self.current_password = ""
        
    def load_data(self):
        """Load data from files"""
        data = {
            'emails': [],
            'usernames': [],
            'passwords': [],
            'displaynames': []
        }
        
        files = {
            'emails': 'mails.txt',
            'usernames': 'usernames.txt',
            'passwords': 'password.txt',
            'displaynames': 'displayname.txt'
        }
        
        for key, filename in files.items():
            try:
                with open(filename, 'r', encoding='utf-8') as f:
                    lines = [line.strip() for line in f.readlines() if line.strip()]
                    if key == 'passwords' and lines:
                        # Use first password for all accounts
                        data[key] = lines[0]
                    else:
                        data[key] = lines
            except FileNotFoundError:
                print(Fore.RED + f"[ ! ] File {filename} not found!")
                return None
        
        return data
    
    def select_browser(self):
        """Select browser for the session"""
        print(rainbow_text("\n[ + ] Please Select the browser that will be used in the Whole Session"))
        print(Fore.WHITE + "Choose browser: ", end="")
        
        browser = input().lower()
        
        if 'chrome' in browser or 'chrom' in browser:
            print(rainbow_text("[ + ] Chrome selected"))
            return 'chrome'
        else:
            print(Fore.RED + "[ ! ] Only Chrome is supported. Exiting...")
            time.sleep(2)
            sys.exit(0)
    
    def setup_driver(self):
        """Setup Chrome driver with options"""
        chrome_options = Options()
        chrome_options.add_argument("--disable-blink-features=AutomationControlled")
        chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
        chrome_options.add_experimental_option('useAutomationExtension', False)
        chrome_options.add_argument("--disable-infobars")
        chrome_options.add_argument("--disable-dev-shm-usage")
        chrome_options.add_argument("--no-sandbox")
        
        # Uncomment for headless mode
        # chrome_options.add_argument("--headless")
        
        try:
            self.driver = webdriver.Chrome(options=chrome_options)
            self.wait = WebDriverWait(self.driver, 10)
            self.driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
        except Exception as e:
            print(Fore.RED + f"[ ! ] Failed to launch browser: {e}")
            return False
        
        return True
    
    def generate_random_date(self):
        """Generate random birth date (year < 2009)"""
        # Generate year between 1990 and 2008
        year = random.randint(1990, 2008)
        month = random.randint(1, 12)
        
        # Handle days per month
        if month in [1, 3, 5, 7, 8, 10, 12]:
            day = random.randint(1, 31)
        elif month == 2:
            # February - handle leap years
            if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
                day = random.randint(1, 29)
            else:
                day = random.randint(1, 28)
        else:
            day = random.randint(1, 30)
        
        return year, month, day
    
    def click_element(self, xpath):
        """Click element by JavaScript click simulation"""
        try:
            element = self.driver.find_element(By.XPATH, xpath)
            self.driver.execute_script("arguments[0].click();", element)
            return True
        except:
            return False
    
    def create_account(self, data):
        """Create Discord account"""
        # Select random data
        self.current_email = random.choice(data['emails'])
        self.current_username = random.choice(data['usernames'])
        self.current_displayname = random.choice(data['displaynames'])
        self.current_password = data['passwords']
        
        print(rainbow_text(f"\n[ + ] Email Acquired from {self.current_email}"))
        print(rainbow_text("[ ! ] Launching Browser"))
        
        if not self.setup_driver():
            return False
        
        try:
            # Open Discord registration page
            self.driver.get("https://discord.com/register")
            time.sleep(3)
            
            # Fill email
            email_field = self.wait.until(
                EC.presence_of_element_located((By.NAME, "email"))
            )
            email_field.clear()
            email_field.send_keys(self.current_email)
            
            # Fill display name
            display_name_field = self.driver.find_element(By.NAME, "global_name")
            display_name_field.clear()
            display_name_field.send_keys(self.current_displayname)
            
            # Fill username
            username_field = self.driver.find_element(By.NAME, "username")
            username_field.clear()
            username_field.send_keys(self.current_username)
            
            # Fill password
            password_field = self.driver.find_element(By.NAME, "password")
            password_field.clear()
            password_field.send_keys(self.current_password)
            
            # Select birth date
            year, month, day = self.generate_random_date()
            
            # Month dropdown
            month_dropdown = self.driver.find_element(By.XPATH, "//div[@aria-label='Month']")
            month_dropdown.click()
            time.sleep(0.5)
            
            month_option = self.driver.find_element(By.XPATH, f"//div[@role='option' and text()='{month:02d}']")
            month_option.click()
            time.sleep(0.5)
            
            # Day dropdown
            day_dropdown = self.driver.find_element(By.XPATH, "//div[@aria-label='Day']")
            day_dropdown.click()
            time.sleep(0.5)
            
            day_option = self.driver.find_element(By.XPATH, f"//div[@role='option' and text()='{day:02d}']")
            day_option.click()
            time.sleep(0.5)
            
            # Year dropdown
            year_dropdown = self.driver.find_element(By.XPATH, "//div[@aria-label='Year']")
            year_dropdown.click()
            time.sleep(0.5)
            
            year_option = self.driver.find_element(By.XPATH, f"//div[@role='option' and text()='{year}']")
            year_option.click()
            time.sleep(0.5)
            
            # Click optional email checkbox
            try:
                # Try to find and click the newsletter checkbox
                newsletter_checkbox = self.driver.find_element(
                    By.XPATH, 
                    "//label[contains(., 'it\'s okay to send me emails with Discord updates, tips and special offers.')]"
                )
                self.driver.execute_script("arguments[0].click();", newsletter_checkbox)
                time.sleep(0.5)
            except:
                pass
            
            # Wait for CAPTCHA (simulated)
            print(rainbow_text("\n[ ! ] Please Solve the captcha"))
            input(Fore.YELLOW + "Press Enter after solving CAPTCHA... ")
            
            print(rainbow_text("[ + ] Captcha Solved"))
            
            # Click Terms of Service
            tos_checkbox = self.driver.find_element(
                By.XPATH, 
                "//input[@type='checkbox' and @aria-label='I have read and agree to Discord's Terms of Service']"
            )
            self.driver.execute_script("arguments[0].click();", tos_checkbox)
            time.sleep(0.5)
            
            # Click Privacy Policy
            privacy_checkbox = self.driver.find_element(
                By.XPATH, 
                "//input[@type='checkbox' and @aria-label='I have read and agree to Discord's Privacy Policy']"
            )
            self.driver.execute_script("arguments[0].click();", privacy_checkbox)
            time.sleep(0.5)
            
            # Click Create Account button
            create_button = self.driver.find_element(
                By.XPATH, 
                "//button[@type='submit']"
            )
            self.driver.execute_script("arguments[0].click();", create_button)
            time.sleep(5)
            
            # Try to get token (this is a simplified simulation)
            # In real scenario, you would need to intercept network requests
            token = self.simulate_token_generation()
            
            if token:
                # Save token to file
                with open('tokens.txt', 'a', encoding='utf-8') as f:
                    f.write(f"{token}\n")
                
                print(rainbow_text(f"[ + ] Token saved: {token[:50]}..."))
            
            # Close browser
            self.driver.quit()
            
            return True
            
        except Exception as e:
            print(Fore.RED + f"[ ! ] Error during account creation: {e}")
            if self.driver:
                self.driver.quit()
            return False
    
    def simulate_token_generation(self):
        """Simulate token generation (for educational purposes)"""
        # This is a simulated token for demonstration
        # In a real scenario, you would extract it from browser storage or network requests
        characters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._-"
        token = "NT"
        
        for _ in range(22):
            token += random.choice(characters)
        
        token += "."
        
        for _ in range(6):
            token += random.choice(characters)
        
        token += "."
        
        for _ in range(27):
            token += random.choice(characters)
        
        return token
    
    def check_files_exist(self):
        """Check if required files exist"""
        required_files = ['mails.txt', 'usernames.txt', 'password.txt', 'displayname.txt']
        
        for file in required_files:
            if not os.path.exists(file):
                print(Fore.RED + f"[ ! ] File {file} not found!")
                print(Fore.YELLOW + "[ + ] Creating empty file...")
                with open(file, 'w', encoding='utf-8') as f:
                    if file == 'mails.txt':
                        f.write("example1@gmail.com\nexample2@yahoo.com\n")
                    elif file == 'usernames.txt':
                        f.write("user123\ncoolguy456\nawesomeuser789\n")
                    elif file == 'password.txt':
                        f.write("StrongPass123!\n")
                    elif file == 'displayname.txt':
                        f.write("John Doe\nAlice Smith\nBob Johnson\n")
        
        print(Fore.GREEN + "[ + ] All required files are ready!")

def main():
    """Main function"""
    # Print banner
    print_banner()
    
    # Check files
    creator = DiscordAccountCreator()
    creator.check_files_exist()
    
    # Select browser
    browser = creator.select_browser()
    
    # Load data
    data = creator.load_data()
    if not data:
        print(Fore.RED + "[ ! ] Failed to load data. Exiting...")
        time.sleep(2)
        sys.exit(1)
    
    # Main loop
    while True:
        # Create account
        success = creator.create_account(data)
        
        if success:
            print(rainbow_text("\n[ + ] Account creation process completed!"))
        
        print(rainbow_text("\n[ ! ] Press Enter to start a new token or 'q' to quit: "))
        user_input = input().lower()
        
        if user_input == 'q':
            break
    
    print(rainbow_text("\n[ + ] Tool exited. Goodbye!"))
    time.sleep(2)

if __name__ == "__main__":
    # Check if running as administrator/root (optional)
    if os.name == 'nt':
        try:
            import ctypes
            is_admin = ctypes.windll.shell32.IsUserAnAdmin()
        except:
            is_admin = False
    else:
        is_admin = os.getuid() == 0
    
    if not is_admin:
        print(Fore.YELLOW + "[ ! ] Run as administrator for better performance")
    
    main()