// commands/security.js
const fs = require('fs');
const path = require('path');
const { EmbedBuilder, PermissionsBitField } = require('discord.js');
const { getGuildSettings } = require('../utils/settings');

module.exports = {
  name: 'security',
  description: 'Enable/disable security for specific category',
  async execute(message, args) {
    if (!message.guild) return;

    const settings = getGuildSettings(message.guild.id, { prefix: '#', embedColor: '#000000' });
    const embedColor = settings.embedColor ? parseInt(settings.embedColor.replace('#',''), 16) : 0x000000;

    if (!message.member.permissions.has(PermissionsBitField.Flags.Administrator)) {
      const noPerms = new EmbedBuilder()
        .setColor(embedColor)
        .setDescription('❌ You need **Administrator** permission to use this command.');
      return message.channel.send({ embeds: [noPerms] });
    }

    const action = args[0]; // enable / false
    const category = args[1]; // ban/kick/rolegive/roleremove/roleupdate
    const punishment = args[2]; // ban/kick/unrole

    if (!action || !category || !punishment) {
      const usage = new EmbedBuilder()
        .setColor(embedColor)
        .setTitle('Command Usage')
        .setDescription(`\`${settings.prefix}security [enable/false] [category] [ban/kick/unrole]\``)
        .setFooter({ text: message.author.username, iconURL: message.author.displayAvatarURL() });
      return message.channel.send({ embeds: [usage] });
    }

    const guildDir = path.join(__dirname, '..', 'data', 'guilds');
    if (!fs.existsSync(guildDir)) fs.mkdirSync(guildDir, { recursive: true });

    const filePath = path.join(guildDir, `${message.guild.id}.json`);
    let guildConfig = {};

    if (fs.existsSync(filePath)) {
      guildConfig = JSON.parse(fs.readFileSync(filePath, 'utf8'));
    }

    if (!guildConfig.security) guildConfig.security = {};

    if (action === 'false') {
      delete guildConfig.security[category];
    } else if (action === 'enable') {
      guildConfig.security[category] = { punishment, whitelist: [] };
    }

    fs.writeFileSync(filePath, JSON.stringify(guildConfig, null, 2));

    const done = new EmbedBuilder()
      .setColor(embedColor)
      .setDescription(`✅ Security for **${category}** ${action === 'false' ? 'disabled' : `enabled with punishment **${punishment}**`}`);
    await message.channel.send({ embeds: [done] });
  }
};




// commands/withelist.js
const fs = require('fs');
const path = require('path');
const { EmbedBuilder, PermissionsBitField } = require('discord.js');
const { getGuildSettings } = require('../utils/settings');

module.exports = {
  name: 'withelist',
  description: 'Add a user to whitelist for a security category',
  async execute(message, args) {
    if (!message.guild) return;

    const settings = getGuildSettings(message.guild.id, { prefix: '#', embedColor: '#000000' });
    const embedColor = settings.embedColor ? parseInt(settings.embedColor.replace('#',''), 16) : 0x000000;

    if (!message.member.permissions.has(PermissionsBitField.Flags.Administrator)) {
      const noPerms = new EmbedBuilder()
        .setColor(embedColor)
        .setDescription('❌ You need **Administrator** permission to use this command.');
      return message.channel.send({ embeds: [noPerms] });
    }

    const user = message.mentions.users.first();
    const category = args[1];

    if (!user || !category) {
      const usage = new EmbedBuilder()
        .setColor(embedColor)
        .setTitle('Command Usage')
        .setDescription(`\`${settings.prefix}withelist [@user] [category]\``)
        .setFooter({ text: message.author.username, iconURL: message.author.displayAvatarURL() });
      return message.channel.send({ embeds: [usage] });
    }

    const guildDir = path.join(__dirname, '..', 'data', 'guilds');
    if (!fs.existsSync(guildDir)) fs.mkdirSync(guildDir, { recursive: true });

    const filePath = path.join(guildDir, `${message.guild.id}.json`);
    let guildConfig = {};

    if (fs.existsSync(filePath)) {
      guildConfig = JSON.parse(fs.readFileSync(filePath, 'utf8'));
    }

    if (!guildConfig.security || !guildConfig.security[category]) {
      const error = new EmbedBuilder()
        .setColor(embedColor)
        .setDescription(`⚠️ Security for **${category}** is not enabled yet.`);
      return message.channel.send({ embeds: [error] });
    }

    if (!guildConfig.security[category].whitelist) guildConfig.security[category].whitelist = [];

    if (!guildConfig.security[category].whitelist.includes(user.id)) {
      guildConfig.security[category].whitelist.push(user.id);
    }

    fs.writeFileSync(filePath, JSON.stringify(guildConfig, null, 2));

    const done = new EmbedBuilder()
      .setColor(embedColor)
      .setDescription(`✅ Added ${user} to whitelist for **${category}**`);
    await message.channel.send({ embeds: [done] });
  }
};




// events/security.js
const fs = require('fs');
const path = require('path');
const { AuditLogEvent } = require('discord.js');

function getGuildConfig(guildId) {
  const filePath = path.join(__dirname, '..', 'data', 'guilds', `${guildId}.json`);
  if (!fs.existsSync(filePath)) return null;
  return JSON.parse(fs.readFileSync(filePath, 'utf8'));
}

async function punish(guild, userId, punishment) {
  const member = await guild.members.fetch(userId).catch(() => null);
  if (!member) return;

  if (punishment === 'ban') {
    await member.ban({ reason: 'Security system' }).catch(() => {});
  } else if (punishment === 'kick') {
    await member.kick('Security system').catch(() => {});
  } else if (punishment === 'unrole') {
    member.roles.set([]).catch(() => {});
  }
}

module.exports = (client) => {
  // Ban
  client.on('guildBanAdd', async (ban) => {
    const config = getGuildConfig(ban.guild.id);
    if (!config || !config.security || !config.security.ban) return;

    const fetchedLogs = await ban.guild.fetchAuditLogs({ type: AuditLogEvent.MemberBanAdd, limit: 1 });
    const log = fetchedLogs.entries.first();
    if (!log) return;

    const execId = log.executor.id;
    if (config.security.ban.whitelist?.includes(execId)) return;

    punish(ban.guild, execId, config.security.ban.punishment);
  });

  // Kick
  client.on('guildMemberRemove', async (member) => {
    const config = getGuildConfig(member.guild.id);
    if (!config || !config.security || !config.security.kick) return;

    const fetchedLogs = await member.guild.fetchAuditLogs({ type: AuditLogEvent.MemberKick, limit: 1 });
    const log = fetchedLogs.entries.first();
    if (!log) return;

    const execId = log.executor.id;
    if (config.security.kick.whitelist?.includes(execId)) return;

    punish(member.guild, execId, config.security.kick.punishment);
  });

  // Role give/remove/update handled via audit logs
  client.on('guildMemberUpdate', async (oldM, newM) => {
    const config = getGuildConfig(newM.guild.id);
    if (!config || !config.security) return;

    const fetchedLogs = await newM.guild.fetchAuditLogs({ limit: 1 });
    const log = fetchedLogs.entries.first();
    if (!log) return;

    const execId = log.executor.id;

    if (log.action === AuditLogEvent.MemberRoleUpdate) {
      if (config.security.rolegive && !config.security.rolegive.whitelist?.includes(execId)) {
        punish(newM.guild, execId, config.security.rolegive.punishment);
      }
      if (config.security.roleremove && !config.security.roleremove.whitelist?.includes(execId)) {
        punish(newM.guild, execId, config.security.roleremove.punishment);
      }
    }
  });

  client.on('roleUpdate', async (oldR, newR) => {
    const config = getGuildConfig(newR.guild.id);
    if (!config || !config.security || !config.security.roleupdate) return;

    const fetchedLogs = await newR.guild.fetchAuditLogs({ type: AuditLogEvent.RoleUpdate, limit: 1 });
    const log = fetchedLogs.entries.first();
    if (!log) return;

    const execId = log.executor.id;
    if (config.security.roleupdate.whitelist?.includes(execId)) return;

    punish(newR.guild, execId, config.security.roleupdate.punishment);
  });
};