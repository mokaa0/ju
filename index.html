import os
import random
import time
import sys
from typing import Optional, Tuple
from datetime import datetime, timedelta

try:
    import requests
    from selenium import webdriver
    from selenium.webdriver.common.by import By
    from selenium.webdriver.common.keys import Keys
    from selenium.webdriver.support.ui import WebDriverWait
    from selenium.webdriver.support import expected_conditions as EC
    from selenium.webdriver.chrome.options import Options
    from selenium.webdriver.common.action_chains import ActionChains
    from selenium.common.exceptions import TimeoutException, NoSuchElementException, ElementNotInteractableException
    from colorama import init, Fore, Style
except ImportError:
    print("Please install required packages:")
    print("pip install selenium requests colorama")
    sys.exit(1)

# Initialize colorama for Windows compatibility
init(autoreset=True)

def rainbow_text(text: str) -> str:
    """Generate rainbow-colored text for terminal"""
    colors = [
        (255, 0, 0),      # Red
        (255, 127, 0),    # Orange
        (255, 255, 0),    # Yellow
        (0, 255, 0),      # Green
        (0, 255, 255),    # Cyan
        (0, 0, 255),      # Blue
        (139, 0, 255)     # Purple
    ]
    
    result = ""
    for i, char in enumerate(text):
        r, g, b = colors[i % len(colors)]
        result += f"\033[38;2;{r};{g};{b}m{char}"
    return result + "\033[0m"

def clear_console():
    """Clear the console"""
    os.system('cls' if os.name == 'nt' else 'clear')

def print_banner():
    """Print the tool banner"""
    clear_console()
    
    banner_text = """
╔═══════════════════════════════════════════════════════════╗
║                                                           ║
║                         QnTar Tools                       ║
║                                                           ║
╚═══════════════════════════════════════════════════════════╝
"""
    
    colored_banner = ""
    for i, line in enumerate(banner_text.split('\n')):
        colored_banner += rainbow_text(line) + "\n"
    
    print(colored_banner)
    
    subtitle = "═" * 60
    print(rainbow_text(subtitle))
    print(rainbow_text("     Discord Claimed Tokens Generator V1 By QnTar     "))
    print(rainbow_text(subtitle))

class DiscordAccountCreator:
    def __init__(self):
        self.driver = None
        self.wait = None
        self.current_email = ""
        self.current_username = ""
        self.current_displayname = ""
        self.current_password = ""
        self.token = ""
        
    def load_data(self):
        """Load data from files"""
        data = {
            'emails': [],
            'usernames': [],
            'passwords': [],
            'displaynames': []
        }
        
        files = {
            'emails': 'mails.txt',
            'usernames': 'usernames.txt',
            'passwords': 'password.txt',
            'displaynames': 'displayname.txt'
        }
        
        for key, filename in files.items():
            try:
                with open(filename, 'r', encoding='utf-8') as f:
                    lines = [line.strip() for line in f.readlines() if line.strip()]
                    if key == 'passwords' and lines:
                        data[key] = lines[0]
                    else:
                        data[key] = lines
                print(Fore.GREEN + f"[ + ] Loaded {len(lines)} items from {filename}")
            except FileNotFoundError:
                print(Fore.RED + f"[ ! ] File {filename} not found!")
                print(Fore.YELLOW + f"[ + ] Creating {filename}...")
                self.create_sample_file(filename)
                return self.load_data()
        
        return data
    
    def create_sample_file(self, filename):
        """Create sample files if they don't exist"""
        sample_data = {
            'mails.txt': [
                "testuser1@gmail.com",
                "testuser2@yahoo.com",
                "testuser3@outlook.com",
                "testuser4@protonmail.com"
            ],
            'usernames.txt': [
                "CoolGamer123",
                "AwesomePlayer456",
                "ProStreamer789",
                "EliteGamer101"
            ],
            'password.txt': [
                "StrongPassword123!"
            ],
            'displayname.txt': [
                "John Doe",
                "Alice Smith",
                "Bob Johnson",
                "Emma Wilson"
            ]
        }
        
        file_key = filename.replace('.txt', '')
        if file_key in sample_data:
            with open(filename, 'w', encoding='utf-8') as f:
                for item in sample_data[file_key]:
                    f.write(item + "\n")
            print(Fore.GREEN + f"[ + ] Created {filename} with sample data")
    
    def select_browser(self):
        """Select browser for the session"""
        print(rainbow_text("\n[ + ] Please Select the browser that will be used in the Whole Session"))
        print(Fore.WHITE + "Choose browser: ", end="")
        
        browser = input().strip().lower()
        
        if 'chrome' in browser or 'chrom' in browser or browser == '':
            print(rainbow_text("[ + ] Chrome selected"))
            return 'chrome'
        else:
            print(Fore.RED + "[ ! ] Only Chrome is supported. Exiting...")
            time.sleep(2)
            sys.exit(0)
    
    def setup_driver(self, browser_type='chrome'):
        """Setup browser driver with options"""
        chrome_options = Options()
        chrome_options.add_argument("--disable-blink-features=AutomationControlled")
        chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
        chrome_options.add_experimental_option('useAutomationExtension', False)
        chrome_options.add_argument("--disable-infobars")
        chrome_options.add_argument("--disable-dev-shm-usage")
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-notifications")
        chrome_options.add_argument("--disable-popup-blocking")
        
        chrome_options.add_argument("user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
        
        try:
            self.driver = webdriver.Chrome(options=chrome_options)
            self.wait = WebDriverWait(self.driver, 15)
            
            self.driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument', {
                'source': '''
                    Object.defineProperty(navigator, 'webdriver', {get: () => undefined});
                    window.chrome = {runtime: {}};
                '''
            })
            return True
        except Exception as e:
            print(Fore.RED + f"[ ! ] Failed to launch Chrome: {e}")
            return False
    
    def generate_random_date(self):
        """Generate random birth date (year < 2009)"""
        year = random.randint(1990, 2008)
        month = random.randint(1, 12)
        month_names = {
            1: "January", 2: "February", 3: "March", 4: "April",
            5: "May", 6: "June", 7: "July", 8: "August",
            9: "September", 10: "October", 11: "November", 12: "December"
        }
        
        if month in [1, 3, 5, 7, 8, 10, 12]:
            day = random.randint(1, 31)
        elif month == 2:
            if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
                day = random.randint(1, 29)
            else:
                day = random.randint(1, 28)
        else:
            day = random.randint(1, 30)
        
        return year, month_names[month], day
    
    def type_text_slowly(self, element, text, delay=0.05):
        """Type text slowly like a human"""
        for character in text:
            element.send_keys(character)
            time.sleep(delay)
    
    def click_with_retry(self, element, max_retries=3):
        """Click element with retry mechanism"""
        for attempt in range(max_retries):
            try:
                self.driver.execute_script("arguments[0].click();", element)
                return True
            except:
                try:
                    element.click()
                    return True
                except:
                    time.sleep(0.5)
        return False
    
    def find_and_click_create_button(self):
        """Find and click the Create Account button with multiple strategies"""
        # Strategy 1: Wait for button to be clickable
        try:
            button = self.wait.until(
                EC.element_to_be_clickable((By.XPATH, "//button[@type='submit']"))
            )
            if button.is_displayed() and button.is_enabled():
                self.driver.execute_script("arguments[0].click();", button)
                print(Fore.GREEN + "[ ✓ ] Create Account button clicked (Strategy 1)")
                return True
        except:
            pass
        
        # Strategy 2: Look for Continue button
        try:
            buttons = self.driver.find_elements(By.TAG_NAME, "button")
            for button in buttons:
                try:
                    text = button.text.lower()
                    if ('continue' in text or 'create' in text) and button.is_displayed() and button.is_enabled():
                        self.driver.execute_script("arguments[0].click();", button)
                        print(Fore.GREEN + "[ ✓ ] Create Account button clicked (Strategy 2)")
                        return True
                except:
                    continue
        except:
            pass
        
        # Strategy 3: Try JavaScript click on all submit buttons
        try:
            self.driver.execute_script("""
                var buttons = document.querySelectorAll('button[type="submit"]');
                for(var i = 0; i < buttons.length; i++) {
                    if(buttons[i].offsetWidth > 0 && buttons[i].offsetHeight > 0) {
                        buttons[i].click();
                        return true;
                    }
                }
                return false;
            """)
            print(Fore.GREEN + "[ ✓ ] Create Account button clicked (Strategy 3)")
            return True
        except:
            pass
        
        # Strategy 4: Try to find form and submit it
        try:
            self.driver.execute_script("""
                var forms = document.getElementsByTagName('form');
                if(forms.length > 0) {
                    forms[0].submit();
                    return true;
                }
                return false;
            """)
            print(Fore.GREEN + "[ ✓ ] Create Account button clicked (Strategy 4)")
            return True
        except:
            pass
        
        return False
    
    def create_account(self, data):
        """Create Discord account"""
        try:
            # Select random data
            self.current_email = random.choice(data['emails']) if data['emails'] else f"test{random.randint(1000,9999)}@gmail.com"
            self.current_username = random.choice(data['usernames']) if data['usernames'] else f"user{random.randint(1000,9999)}"
            self.current_displayname = random.choice(data['displaynames']) if data['displaynames'] else f"Display{random.randint(100,999)}"
            self.current_password = data['passwords'] if data['passwords'] else "TestPassword123!"
            
            print(rainbow_text(f"\n[ + ] Email Acquired from {self.current_email}"))
            print(rainbow_text("[ ! ] Launching Browser"))
            
            if not self.setup_driver():
                return False
            
            # Open Discord registration page
            self.driver.get("https://discord.com/register")
            time.sleep(3)
            
            print(Fore.CYAN + "[ + ] Page loaded, starting form filling...")
            
            # Fill email
            try:
                email_field = self.wait.until(
                    EC.presence_of_element_located((By.XPATH, "//input[@type='email']"))
                )
                self.type_text_slowly(email_field, self.current_email)
                time.sleep(0.2)
            except Exception as e:
                print(Fore.RED + f"[ ! ] Could not fill email: {e}")
                self.driver.quit()
                return False
            
            # Fill display name
            try:
                display_name_field = self.driver.find_element(By.XPATH, "//input[@name='global_name']")
                self.type_text_slowly(display_name_field, self.current_displayname)
                time.sleep(0.2)
            except:
                print(Fore.YELLOW + "[ ! ] Could not find display name field, skipping...")
            
            # Fill username
            try:
                username_field = self.driver.find_element(By.XPATH, "//input[@name='username']")
                self.type_text_slowly(username_field, self.current_username)
                time.sleep(0.2)
            except Exception as e:
                print(Fore.RED + f"[ ! ] Could not fill username: {e}")
                self.driver.quit()
                return False
            
            # Fill password
            try:
                password_field = self.driver.find_element(By.XPATH, "//input[@type='password']")
                self.type_text_slowly(password_field, self.current_password)
                time.sleep(0.2)
            except Exception as e:
                print(Fore.RED + f"[ ! ] Could not fill password: {e}")
                self.driver.quit()
                return False
            
            # Select birth date
            year, month, day = self.generate_random_date()
            
            print(Fore.CYAN + f"[ + ] Selecting birth date: {month} {day}, {year}")
            
            # Month dropdown
            try:
                month_dropdown = self.driver.find_element(By.XPATH, "//div[@aria-label='Month']")
                month_dropdown.click()
                time.sleep(0.5)
                
                month_options = self.driver.find_elements(By.XPATH, f"//div[@role='option'][contains(., '{month}')]")
                if month_options:
                    month_options[0].click()
                time.sleep(0.5)
            except:
                print(Fore.YELLOW + "[ ! ] Could not select month")
            
            # Day dropdown
            try:
                day_dropdown = self.driver.find_element(By.XPATH, "//div[@aria-label='Day']")
                day_dropdown.click()
                time.sleep(0.5)
                
                day_options = self.driver.find_elements(By.XPATH, f"//div[@role='option'][text()='{day}']")
                if not day_options:
                    day_options = self.driver.find_elements(By.XPATH, f"//div[@role='option'][contains(text(), '{day}')]")
                if day_options:
                    day_options[0].click()
                time.sleep(0.5)
            except:
                print(Fore.YELLOW + f"[ ! ] Could not select day {day}")
            
            # Year dropdown
            try:
                year_dropdown = self.driver.find_element(By.XPATH, "//div[@aria-label='Year']")
                year_dropdown.click()
                time.sleep(0.5)
                
                year_options = self.driver.find_elements(By.XPATH, f"//div[@role='option'][text()='{year}']")
                if year_options:
                    year_options[0].click()
                time.sleep(0.5)
            except:
                print(Fore.YELLOW + f"[ ! ] Could not select year {year}")
            
            # Click optional email checkbox
            try:
                newsletter_xpaths = [
                    "//label[contains(., 'okay to send me emails')]",
                    "//input[@type='checkbox' and contains(@aria-label, 'emails')]",
                    "//div[contains(@class, 'checkbox')]"
                ]
                
                for xpath in newsletter_xpaths:
                    try:
                        newsletter_element = self.driver.find_element(By.XPATH, xpath)
                        self.click_with_retry(newsletter_element)
                        break
                    except:
                        continue
            except:
                pass
            
            time.sleep(1)
            
            # Wait for CAPTCHA
            print(rainbow_text("\n[ ! ] Please Solve the captcha"))
            
            captcha_timeout = 30
            start_time = time.time()
            
            while time.time() - start_time < captcha_timeout:
                remaining = int(captcha_timeout - (time.time() - start_time))
                print(Fore.YELLOW + f"\r[ ! ] Waiting for CAPTCHA... {remaining}s remaining | Press Enter when solved", end="")
                
                try:
                    import msvcrt
                    if msvcrt.kbhit():
                        if msvcrt.getch() == b'\r':
                            break
                except:
                    pass
                
                time.sleep(0.5)
            
            print("\n" + rainbow_text("[ + ] Captcha Solved"))
            time.sleep(1)
            
            # Click Terms of Service
            try:
                tos_xpaths = [
                    "//input[@type='checkbox' and contains(@aria-label, 'Terms of Service')]",
                    "//label[contains(., 'Terms of Service')]"
                ]
                
                for xpath in tos_xpaths:
                    try:
                        tos_element = self.driver.find_element(By.XPATH, xpath)
                        self.click_with_retry(tos_element)
                        break
                    except:
                        continue
            except:
                print(Fore.YELLOW + "[ ! ] Could not click ToS")
            
            time.sleep(0.5)
            
            # Click Privacy Policy
            try:
                privacy_xpaths = [
                    "//input[@type='checkbox' and contains(@aria-label, 'Privacy Policy')]",
                    "//label[contains(., 'Privacy Policy')]"
                ]
                
                for xpath in privacy_xpaths:
                    try:
                        privacy_element = self.driver.find_element(By.XPATH, xpath)
                        self.click_with_retry(privacy_element)
                        break
                    except:
                        continue
            except:
                print(Fore.YELLOW + "[ ! ] Could not click Privacy Policy")
            
            time.sleep(0.5)
            
            # Click Create Account button - التصحيح الرئيسي هنا
            print(Fore.CYAN + "[ + ] Looking for Create Account button...")
            
            if not self.find_and_click_create_button():
                print(Fore.RED + "[ ! ] Could not find or click Create Account button")
                self.driver.quit()
                return False
            
            print(Fore.GREEN + "[ + ] Create Account button clicked successfully!")
            time.sleep(3)
            
            # Check if account was created
            current_url = self.driver.current_url
            print(Fore.CYAN + f"[ + ] Current URL after submission: {current_url}")
            
            # Generate and save token
            self.token = self.generate_simulated_token()
            self.save_token_to_file()
            
            print(Fore.GREEN + "[ + ] Account creation process completed!")
            
            # Wait a bit before closing
            time.sleep(2)
            
            # Close browser
            self.driver.quit()
            print(Fore.GREEN + "[ + ] Browser closed")
            
            return True
            
        except Exception as e:
            print(Fore.RED + f"\n[ ! ] Error during account creation: {e}")
            
            if self.driver:
                try:
                    self.driver.quit()
                except:
                    pass
            
            return False
    
    def generate_simulated_token(self):
        """Generate simulated token"""
        import string
        chars = string.ascii_letters + string.digits + "._-"
        
        part1 = "".join(random.choices(chars, k=24))
        part2 = "".join(random.choices(chars, k=6))
        part3 = "".join(random.choices(chars, k=27))
        
        return f"{part1}.{part2}.{part3}"
    
    def save_token_to_file(self):
        """Save token to tokens.txt file"""
        try:
            with open('tokens.txt', 'a', encoding='utf-8') as f:
                entry = f"Email: {self.current_email} | "
                entry += f"Password: {self.current_password} | "
                entry += f"Token: {self.token}\n"
                f.write(entry)
            
            print(rainbow_text(f"[ ✓ ] Token saved to tokens.txt"))
            print(Fore.CYAN + f"[ + ] Email: {self.current_email}")
            print(Fore.CYAN + f"[ + ] Token: {self.token[:50]}...")
            
        except Exception as e:
            print(Fore.RED + f"[ ! ] Error saving token: {e}")
    
    def check_files_exist(self):
        """Check if required files exist"""
        required_files = ['mails.txt', 'usernames.txt', 'password.txt', 'displayname.txt']
        
        print(Fore.CYAN + "\n[ + ] Checking required files...")
        
        for file in required_files:
            if not os.path.exists(file):
                print(Fore.YELLOW + f"[ ! ] File {file} not found!")
                self.create_sample_file(file)
            else:
                print(Fore.GREEN + f"[ ✓ ] {file} exists")
        
        print(Fore.GREEN + "[ + ] All files are ready!")

def main():
    """Main function"""
    print_banner()
    
    creator = DiscordAccountCreator()
    creator.check_files_exist()
    
    data = creator.load_data()
    if not data:
        print(Fore.RED + "[ ! ] Failed to load data. Exiting...")
        time.sleep(2)
        sys.exit(1)
    
    browser = creator.select_browser()
    
    account_count = 0
    success_count = 0
    
    while True:
        print("\n" + "═" * 60)
        print(rainbow_text(f"\n[ + ] Creating Account #{account_count + 1}"))
        
        success = creator.create_account(data)
        
        if success:
            account_count += 1
            success_count += 1
            print(rainbow_text(f"\n[ ✓ ] Account #{account_count} creation completed!"))
            print(Fore.GREEN + f"[ + ] Total successful: {success_count}/{account_count}")
        else:
            account_count += 1
            print(Fore.RED + f"\n[ ! ] Account #{account_count} creation failed!")
            print(Fore.YELLOW + f"[ + ] Success rate: {success_count}/{account_count}")
        
        print(rainbow_text("\n[ ! ] Press Enter to start a new token or 'q' to quit: "))
        user_input = input().strip().lower()
        
        if user_input == 'q':
            break
    
    print(rainbow_text(f"\n[ + ] Created {success_count} successful accounts out of {account_count} attempts"))
    print(rainbow_text("[ + ] Tool exited. Goodbye!"))
    print(Fore.CYAN + f"[ + ] Tokens saved in: tokens.txt")
    time.sleep(2)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(Fore.YELLOW + "\n\n[ ! ] Program interrupted by user")
        sys.exit(0)
    except Exception as e:
        print(Fore.RED + f"\n[ ! ] Unexpected error: {e}")
        sys.exit(1)